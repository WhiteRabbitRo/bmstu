# Сортировка

* Сложность лучший/средний/худший случай, (также важно знать как часть возникает хужший случай).
* использование памяти
    1. тип сортировки:
        - ин-плейс / внутренняя
        - не-инплейс / внешняя
    2. колличество ячеек
* устойчивость (сортировка устойчивая - если сохраняется порядка одинаковых элементов).
* возможность распараллеливать.
* адаптивность (сортировка адаптивная - если работает быстрее на частично отсортированной последовательности).
* Принцып работы.

### Q: Зачем нужна устойчивость?
### A:
    Если идет сотировка по нескольким параметрам, то порядок
    сортировки по одному сохранится про сортировке по другим
    параметрам.

## Сортировка вставками.

* инплейс
* устойчивость (первый из конвоя первый в новый массив, второй из конвоя вторым)
* адаптивно

Массив разделен на отсортированную часть и не отсортированную. Элементы по очереди из неотсортированной части выбираются и вставляются в нужное место в отсортированной.

```
function IncertSort( array A )
| let boundry #sorted/unsorted boundry
| boundry = -1
| for boundry from -1 to A.size-1 do
| | let temp_min = A[boundry + 1]
| | let temp_min_index = boundry+1
| | for i from boundry+2 to A.size do
| | | if (A[i] < min)
| | | | temp_min = A[i]
| | | | temp_min_index = i
| | swap(A[boundry+1], A[temp_min_index])
| return A
```

## Сортировка пузырьком

* инплейс
* адаптивно (с флагом)
* устойчивость (строгие отношение)
* не параллелится

Попарно сравниваются элементы и обмениваются местами до тех пор пока массив не отсортирован.

```
function BublySort( array A )
| for i from 0 to n - 2 do
| | let flag = true
| | for j from 0 to n - i - 2 do
| | | if A[j] < A[j+1]
| | | | swap (A[j], A[j+1])
| | | | invert(flag)
| | if flag break
| return A
```

## Сортировка выбором

* Во всех О(n^2)
* не устойчиво
* не параллелится
* не адаптивно

Массив делитс на отсортированную и не отсортированную часть. В неотсортированной части выбирается минимум, он является максимумом для отсортированной, отсортированная часть увеличивается. Повторяется до тех пор пока массив не закончится.

```
function SelectSort( array A )
| for i from 0 to n - 2 do
| | let imax = i
| | for j from i to n - 1 do
| | | if (A[imax] < A[j])
| | | | imax = j
| | swap(A[imax], A[i])
| return A
```
