
0. сд
1. дд в массиве
2. все уровни заполнены (кроме последнего)
3. последний уровень заполняется слева направо
4. parent.key >= child.key
5.
``` index(root) = 0
    index(child) = {2*index(parent) + 1
                   {2*index(parent) + 2
```

в виде дерева
```
                  90
              /        \
            70          10
        /   |           |   \
    40      1           1     2
  /   \    / \          |\   /|
10    3   0  x          x ... x
```

в виде массива
```
90 | 70 10 | 40 1 1 2 | 10 3 0
```

- Используется для очередей с приоритетом.
- Алгоритм поиска кротчайшего пути на графе

## Процедура добавления

- Добавляем по правилу (3)
- sift up / bubble up

### Пример заполнения

10 20 30 15 35 3 2 14 69

1.
```
10
```

2.
```
10      20
 | ->    |
20      10
```

3.
```
20          30
| \    ->   | \
10 30       10 20
```

4.
```
30          30
| \         | \
10 20  ->   15 20
|           |
15          10
```

5.
```
30          30        35
| \         | \       | \
15 20   ->  35 20  -> 30 20
| \         | \       | \
10 35       10 15     10 15
```

6&7.
```
35
|       \
30      20
| \     | \
10 15   3 2
```

8.
```
35              35
|       \       |          \
30      20   -> 30          20
| \     | \     | \         | \
10 15   3 2     14 15       3  2
|               |
14              10
```

9. ``` nyet ```

### heapify & sift_down


```
N             ^
|    \        <heap>
^     ^   ->
p1    p2
<h1> <h2>
```

```
p1
|       \
N       p2
| \     <h3>
h1 h2   
```
